---
layout:     post                    # 使用的布局（不需要改）
title:      动态规划入门               # 标题 
subtitle:   本文将介绍动态规划基本实现以及LeetCode几道简单的题目 #副标题
date:       2020-04-23              # 时间
author:     Vega                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 动态规划
    - Golang
---



# 动态规划入门

## 什么是动态规划

---

> 动态规划是一个**自底向上的过程**，要使用动态规划，需要具备以下特性

+ **最优子结构：**大规模问题的最优解，能通过小规模问题的最优解推导出来。
+ **无后效性：**某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策影响。当前的若干个状态值一旦确定，则此后过程的演变之和这若干个状态值有关，和之前的决策路径没有关系

## 动态规划与分治法的差别

---

+ **分治法：大规模问题可以通过解决子问题得出，这若干个子问题之间相互独立。**
+ **动态规划：大规模问题可以通过解决子问题得出，这若干个子问题之间有必然联系。**

**举个例子：斐波那契数（LeetCode:509）**

分治法

```go
func fibArray(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	if n >= 2 {
		return fibArray(n-1) + fibArray(n-2)
	}
	return 0
}
```

动态规划

```go
func fibArray(n int) int {
	if n == 0 {
		return 0
	}
	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1
	for i := 2; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}

//空间优化
func fibArray(n int) int {
	if n == 0 {
		return 0
	}
	dp1 := 1
	dp2 := 1
	for i := 2; i <= n; i++ {
		dp1, dp2 = dp2, dp1+dp2
	}
	return dp2
}
```

乍看之下，这两个方法没什么差别，但是对于n比较小的情况可能还好，但是当n大到一定程度，例如n=100，分治法可能一时半会算不出来了。根本原因在于，F(n)=F(n-1)+F(n-2)，分治法会分别递归的去计算 F(n-1)和 F(n-2)，而 F(n-1)=F(n-2)+F(n-3)，也就是说，计算 F(n-1)的时候，就已经计算了 F(n-2)，但是在另一边的递归里面，又再次计算 F(n-2)，如果再往下拓展，会发现同样的 F(x)被多次重复的求值，而动态规划第一版，则是将计算结果储存起来，之后要用到，直接取值，不需要重复去计算。因为每次求值，只会用到前2个结果，于是就有了空间优化版，只记录前2个解。



## 解题思路

---

1. 将原问题转化为子问题
2. 确定状态
3. 确定边界条件
4. 确定状态转移方程